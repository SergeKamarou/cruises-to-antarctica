/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./js/vendor.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../node_modules/process/browser.js":
/*!******************************************!*\
  !*** ../node_modules/process/browser.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "../node_modules/setimmediate/setImmediate.js":
/*!****************************************************!*\
  !*** ../node_modules/setimmediate/setImmediate.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "../node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "../node_modules/process/browser.js")))

/***/ }),

/***/ "../node_modules/timers-browserify/main.js":
/*!*************************************************!*\
  !*** ../node_modules/timers-browserify/main.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ "../node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/webpack/buildin/global.js":
/*!*************************************************!*\
  !*** ../node_modules/webpack/buildin/global.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./js/vendor.js":
/*!**********************!*\
  !*** ./js/vendor.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _vendor_focus_visible_polyfill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vendor/focus-visible-polyfill */ "./js/vendor/focus-visible-polyfill.js");
/* harmony import */ var _vendor_focus_visible_polyfill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_vendor_focus_visible_polyfill__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _vendor_ymaps__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vendor/ymaps */ "./js/vendor/ymaps.js");
/* harmony import */ var _vendor_ymaps__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_vendor_ymaps__WEBPACK_IMPORTED_MODULE_1__);



/***/ }),

/***/ "./js/vendor/focus-visible-polyfill.js":
/*!*********************************************!*\
  !*** ./js/vendor/focus-visible-polyfill.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Applies the :focus-visible polyfill at the given scope.
 * A scope in this case is either the top-level Document or a Shadow Root.
 *
 * @param {(Document|ShadowRoot)} scope
 * @see https://github.com/WICG/focus-visible
 */
function applyFocusVisiblePolyfill(scope) {
  var hadKeyboardEvent = true;
  var hadFocusVisibleRecently = false;
  var hadFocusVisibleRecentlyTimeout = null;
  var inputTypesAllowlist = {
    text: true,
    search: true,
    url: true,
    tel: true,
    email: true,
    password: true,
    number: true,
    date: true,
    month: true,
    week: true,
    time: true,
    datetime: true,
    'datetime-local': true
  };

  /**
   * Helper function for legacy browsers and iframes which sometimes focus
   * elements like document, body, and non-interactive SVG.
   * @param {Element} el
   */
  function isValidFocusTarget(el) {
    if (el && el !== document && el.nodeName !== 'HTML' && el.nodeName !== 'BODY' && 'classList' in el && 'contains' in el.classList) {
      return true;
    }
    return false;
  }

  /**
   * Computes whether the given element should automatically trigger the
   * `focus-visible` class being added, i.e. whether it should always match
   * `:focus-visible` when focused.
   * @param {Element} el
   * @return {boolean}
   */
  function focusTriggersKeyboardModality(el) {
    var type = el.type;
    var tagName = el.tagName;
    if (tagName === 'INPUT' && inputTypesAllowlist[type] && !el.readOnly) {
      return true;
    }
    if (tagName === 'TEXTAREA' && !el.readOnly) {
      return true;
    }
    if (el.isContentEditable) {
      return true;
    }
    return false;
  }

  /**
   * Add the `focus-visible` class to the given element if it was not added by
   * the author.
   * @param {Element} el
   */
  function addFocusVisibleClass(el) {
    if (el.classList.contains('focus-visible')) {
      return;
    }
    el.classList.add('focus-visible');
    el.setAttribute('data-focus-visible-added', '');
  }

  /**
   * Remove the `focus-visible` class from the given element if it was not
   * originally added by the author.
   * @param {Element} el
   */
  function removeFocusVisibleClass(el) {
    if (!el.hasAttribute('data-focus-visible-added')) {
      return;
    }
    el.classList.remove('focus-visible');
    el.removeAttribute('data-focus-visible-added');
  }

  /**
   * If the most recent user interaction was via the keyboard;
   * and the key press did not include a meta, alt/option, or control key;
   * then the modality is keyboard. Otherwise, the modality is not keyboard.
   * Apply `focus-visible` to any current active element and keep track
   * of our keyboard modality state with `hadKeyboardEvent`.
   * @param {KeyboardEvent} e
   */
  function onKeyDown(e) {
    if (e.metaKey || e.altKey || e.ctrlKey) {
      return;
    }
    if (isValidFocusTarget(scope.activeElement)) {
      addFocusVisibleClass(scope.activeElement);
    }
    hadKeyboardEvent = true;
  }

  /**
   * If at any point a user clicks with a pointing device, ensure that we change
   * the modality away from keyboard.
   * This avoids the situation where a user presses a key on an already focused
   * element, and then clicks on a different element, focusing it with a
   * pointing device, while we still think we're in keyboard modality.
   * @param {Event} e
   */
  function onPointerDown(e) {
    hadKeyboardEvent = false;
  }

  /**
   * On `focus`, add the `focus-visible` class to the target if:
   * - the target received focus as a result of keyboard navigation, or
   * - the event target is an element that will likely require interaction
   *   via the keyboard (e.g. a text box)
   * @param {Event} e
   */
  function onFocus(e) {
    // Prevent IE from focusing the document or HTML element.
    if (!isValidFocusTarget(e.target)) {
      return;
    }
    if (hadKeyboardEvent || focusTriggersKeyboardModality(e.target)) {
      addFocusVisibleClass(e.target);
    }
  }

  /**
   * On `blur`, remove the `focus-visible` class from the target.
   * @param {Event} e
   */
  function onBlur(e) {
    if (!isValidFocusTarget(e.target)) {
      return;
    }
    if (e.target.classList.contains('focus-visible') || e.target.hasAttribute('data-focus-visible-added')) {
      // To detect a tab/window switch, we look for a blur event followed
      // rapidly by a visibility change.
      // If we don't see a visibility change within 100ms, it's probably a
      // regular focus change.
      hadFocusVisibleRecently = true;
      window.clearTimeout(hadFocusVisibleRecentlyTimeout);
      hadFocusVisibleRecentlyTimeout = window.setTimeout(function () {
        hadFocusVisibleRecently = false;
      }, 100);
      removeFocusVisibleClass(e.target);
    }
  }

  /**
   * If the user changes tabs, keep track of whether or not the previously
   * focused element had .focus-visible.
   * @param {Event} e
   */
  function onVisibilityChange(e) {
    if (document.visibilityState === 'hidden') {
      // If the tab becomes active again, the browser will handle calling focus
      // on the element (Safari actually calls it twice).
      // If this tab change caused a blur on an element with focus-visible,
      // re-apply the class when the user switches back to the tab.
      if (hadFocusVisibleRecently) {
        hadKeyboardEvent = true;
      }
      addInitialPointerMoveListeners();
    }
  }

  /**
   * Add a group of listeners to detect usage of any pointing devices.
   * These listeners will be added when the polyfill first loads, and anytime
   * the window is blurred, so that they are active when the window regains
   * focus.
   */
  function addInitialPointerMoveListeners() {
    document.addEventListener('mousemove', onInitialPointerMove);
    document.addEventListener('mousedown', onInitialPointerMove);
    document.addEventListener('mouseup', onInitialPointerMove);
    document.addEventListener('pointermove', onInitialPointerMove);
    document.addEventListener('pointerdown', onInitialPointerMove);
    document.addEventListener('pointerup', onInitialPointerMove);
    document.addEventListener('touchmove', onInitialPointerMove);
    document.addEventListener('touchstart', onInitialPointerMove);
    document.addEventListener('touchend', onInitialPointerMove);
  }
  function removeInitialPointerMoveListeners() {
    document.removeEventListener('mousemove', onInitialPointerMove);
    document.removeEventListener('mousedown', onInitialPointerMove);
    document.removeEventListener('mouseup', onInitialPointerMove);
    document.removeEventListener('pointermove', onInitialPointerMove);
    document.removeEventListener('pointerdown', onInitialPointerMove);
    document.removeEventListener('pointerup', onInitialPointerMove);
    document.removeEventListener('touchmove', onInitialPointerMove);
    document.removeEventListener('touchstart', onInitialPointerMove);
    document.removeEventListener('touchend', onInitialPointerMove);
  }

  /**
   * When the polfyill first loads, assume the user is in keyboard modality.
   * If any event is received from a pointing device (e.g. mouse, pointer,
   * touch), turn off keyboard modality.
   * This accounts for situations where focus enters the page from the URL bar.
   * @param {Event} e
   */
  function onInitialPointerMove(e) {
    // Work around a Safari quirk that fires a mousemove on <html> whenever the
    // window blurs, even if you're tabbing out of the page. ¯\_(ツ)_/¯
    if (e.target.nodeName && e.target.nodeName.toLowerCase() === 'html') {
      return;
    }
    hadKeyboardEvent = false;
    removeInitialPointerMoveListeners();
  }

  // For some kinds of state, we are interested in changes at the global scope
  // only. For example, global pointer input, global key presses and global
  // visibility change should affect the state at every scope:
  document.addEventListener('keydown', onKeyDown, true);
  document.addEventListener('mousedown', onPointerDown, true);
  document.addEventListener('pointerdown', onPointerDown, true);
  document.addEventListener('touchstart', onPointerDown, true);
  document.addEventListener('visibilitychange', onVisibilityChange, true);
  addInitialPointerMoveListeners();

  // For focus and blur, we specifically care about state changes in the local
  // scope. This is because focus / blur events that originate from within a
  // shadow root are not re-dispatched from the host element if it was already
  // the active element in its own scope:
  scope.addEventListener('focus', onFocus, true);
  scope.addEventListener('blur', onBlur, true);

  // We detect that a node is a ShadowRoot by ensuring that it is a
  // DocumentFragment and also has a host property. This check covers native
  // implementation and polyfill implementation transparently. If we only cared
  // about the native implementation, we could just check if the scope was
  // an instance of a ShadowRoot.
  if (scope.nodeType === Node.DOCUMENT_FRAGMENT_NODE && scope.host) {
    // Since a ShadowRoot is a special kind of DocumentFragment, it does not
    // have a root element to add a class to. So, we add this attribute to the
    // host element instead:
    scope.host.setAttribute('data-js-focus-visible', '');
  } else if (scope.nodeType === Node.DOCUMENT_NODE) {
    document.documentElement.classList.add('js-focus-visible');
    document.documentElement.setAttribute('data-js-focus-visible', '');
  }
}

// It is important to wrap all references to global window and document in
// these checks to support server-side rendering use cases
// @see https://github.com/WICG/focus-visible/issues/199
if (typeof window !== 'undefined' && typeof document !== 'undefined') {
  // Make the polyfill helper globally available. This can be used as a signal
  // to interested libraries that wish to coordinate with the polyfill for e.g.,
  // applying the polyfill to a shadow root:
  window.applyFocusVisiblePolyfill = applyFocusVisiblePolyfill;

  // Notify interested libraries of the polyfill's presence, in case the
  // polyfill was loaded lazily:
  var event;
  try {
    event = new CustomEvent('focus-visible-polyfill-ready');
  } catch (error) {
    // IE11 does not support using CustomEvent as a constructor directly:
    event = document.createEvent('CustomEvent');
    event.initCustomEvent('focus-visible-polyfill-ready', false, false, {});
  }
  window.dispatchEvent(event);
}
if (typeof document !== 'undefined') {
  // Apply the polyfill to the global document, so that no JavaScript
  // coordination is required to use the polyfill in the top-level document:
  applyFocusVisiblePolyfill(document);
}

/***/ }),

/***/ "./js/vendor/ymaps.js":
/*!****************************!*\
  !*** ./js/vendor/ymaps.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(setImmediate, process) {function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
(function ymapsInit(e) {
  var n = this,
    t = {
      ns: {},
      supports: {},
      env: e
    };
  t.performance = {
    now: n.performance && n.performance.now ? n.performance.now.bind(n.performance) : function () {
      return Date.now();
    }
  }, t.count = function (e) {
    function n() {
      r.push(arguments);
    }
    var t = {
        exports: {}
      },
      r = (t.exports, []),
      o = null,
      i = function i() {
        (o || n).apply(null, arguments);
      };
    return i.provideImplementation = function (e) {
      if (o) throw new Error("ym.count: implementation was already provided.");
      o = e(r);
    }, t.exports = i, t.exports;
  }(), t.vow = t.ns.vow = function (e) {
    var t,
      r = {
        exports: {}
      };
    r.exports;
    return function (e) {
      var n,
        o = function () {
          var n = [],
            t = function t(e) {
              return n.push(e), 1 === n.length;
            },
            r = function r() {
              var e = n,
                t = 0,
                r = n.length;
              for (n = []; t < r;) {
                e[t++]();
              }
            };
          if ("function" == typeof setImmediate) return function (e) {
            t(e) && setImmediate(r);
          };
          if ("object" == (typeof process === "undefined" ? "undefined" : _typeof(process)) && process.nextTick) return function (e) {
            t(e) && process.nextTick(r);
          };
          var o = e.MutationObserver || e.WebKitMutationObserver;
          if (o) {
            var i = 1,
              s = document.createTextNode("");
            return new o(r).observe(s, {
              characterData: !0
            }), function (e) {
              t(e) && (s.data = i *= -1);
            };
          }
          if (e.postMessage) {
            var a = !0;
            if (e.attachEvent) {
              var u = function u() {
                a = !1;
              };
              e.attachEvent("onmessage", u), e.postMessage("__checkAsync", "*"), e.detachEvent("onmessage", u);
            }
            if (a) {
              var c = "__promise" + Math.random() + "_" + new Date(),
                l = function l(e) {
                  e.data === c && (e.stopPropagation && e.stopPropagation(), r());
                };
              return e.addEventListener ? e.addEventListener("message", l, !0) : e.attachEvent("onmessage", l), function (n) {
                t(n) && e.postMessage(c, "*");
              };
            }
          }
          var f = e.document;
          if ("onreadystatechange" in f.createElement("script")) {
            var d = function d() {
              var e = f.createElement("script");
              e.onreadystatechange = function () {
                e.parentNode.removeChild(e), e = e.onreadystatechange = null, r();
              }, (f.documentElement || f.body).appendChild(e);
            };
            return function (e) {
              t(e) && d();
            };
          }
          return function (e) {
            t(e) && setTimeout(r, 0);
          };
        }(),
        i = function i(e) {
          o(function () {
            throw e;
          });
        },
        s = function s(e) {
          return "function" == typeof e;
        },
        a = function a(e) {
          return null !== e && "object" == _typeof(e);
        },
        u = Object.prototype.toString,
        c = Array.isArray || function (e) {
          return "[object Array]" === u.call(e);
        },
        l = function l(e) {
          for (var n = [], t = 0, r = e.length; t < r;) {
            n.push(t++);
          }
          return n;
        },
        f = Object.keys || function (e) {
          var n = [];
          for (var t in e) {
            e.hasOwnProperty(t) && n.push(t);
          }
          return n;
        },
        d = function d(e) {
          var n = function n(_n) {
            this.name = e, this.message = _n;
          };
          return n.prototype = new Error(), n;
        },
        p = function p(e, n) {
          return function (t) {
            e.call(this, t, n);
          };
        },
        v = function v() {
          this._promise = new m();
        };
      v.prototype = {
        promise: function promise() {
          return this._promise;
        },
        resolve: function resolve(e) {
          this._promise.isResolved() || this._promise._resolve(e);
        },
        reject: function reject(e) {
          this._promise.isResolved() || (_.isPromise(e) ? (e = e.then(function (e) {
            var n = _.defer();
            return n.reject(e), n.promise();
          }), this._promise._resolve(e)) : this._promise._reject(e));
        },
        notify: function notify(e) {
          this._promise.isResolved() || this._promise._notify(e);
        }
      };
      var h = {
          PENDING: 0,
          RESOLVED: 1,
          FULFILLED: 2,
          REJECTED: 3
        },
        m = function m(e) {
          if (this._value = n, this._status = h.PENDING, this._fulfilledCallbacks = [], this._rejectedCallbacks = [], this._progressCallbacks = [], e) {
            var t = this,
              r = e.length;
            e(function (e) {
              t.isResolved() || t._resolve(e);
            }, r > 1 ? function (e) {
              t.isResolved() || t._reject(e);
            } : n, r > 2 ? function (e) {
              t.isResolved() || t._notify(e);
            } : n);
          }
        };
      m.prototype = {
        valueOf: function valueOf() {
          return this._value;
        },
        isResolved: function isResolved() {
          return this._status !== h.PENDING;
        },
        isFulfilled: function isFulfilled() {
          return this._status === h.FULFILLED;
        },
        isRejected: function isRejected() {
          return this._status === h.REJECTED;
        },
        then: function then(e, n, t, r) {
          var o = new v();
          return this._addCallbacks(o, e, n, t, r), o.promise();
        },
        "catch": function _catch(e, t) {
          return this.then(n, e, t);
        },
        fail: function fail(e, t) {
          return this.then(n, e, t);
        },
        always: function always(e, n) {
          var t = this,
            r = function r() {
              return e.call(this, t);
            };
          return this.then(r, r, n);
        },
        progress: function progress(e, t) {
          return this.then(n, n, e, t);
        },
        spread: function spread(e, n, t) {
          return this.then(function (n) {
            return e.apply(this, n);
          }, n, t);
        },
        done: function done(e, n, t, r) {
          this.then(e, n, t, r).fail(i);
        },
        delay: function delay(e) {
          var n,
            t = this.then(function (t) {
              var r = new v();
              return n = setTimeout(function () {
                r.resolve(t);
              }, e), r.promise();
            });
          return t.always(function () {
            clearTimeout(n);
          }), t;
        },
        timeout: function timeout(e) {
          var n = new v(),
            t = setTimeout(function () {
              n.reject(new _.TimedOutError("timed out"));
            }, e);
          return this.then(function (e) {
            n.resolve(e);
          }, function (e) {
            n.reject(e);
          }), n.promise().always(function () {
            clearTimeout(t);
          }), n.promise();
        },
        _vow: !0,
        _resolve: function _resolve(e) {
          if (!(this._status > h.RESOLVED)) {
            if (e === this) return void this._reject(TypeError("Can't resolve promise with itself"));
            if (this._status = h.RESOLVED, e && e._vow) return void (e.isFulfilled() ? this._fulfill(e.valueOf()) : e.isRejected() ? this._reject(e.valueOf()) : e.then(this._fulfill, this._reject, this._notify, this));
            if (a(e) || s(e)) {
              var n;
              try {
                n = e.then;
              } catch (t) {
                return void this._reject(t);
              }
              if (s(n)) {
                var r = this,
                  o = !1;
                try {
                  n.call(e, function (e) {
                    o || (o = !0, r._resolve(e));
                  }, function (e) {
                    o || (o = !0, r._reject(e));
                  }, function (e) {
                    r._notify(e);
                  });
                } catch (t) {
                  o || this._reject(t);
                }
                return;
              }
            }
            this._fulfill(e);
          }
        },
        _fulfill: function _fulfill(e) {
          this._status > h.RESOLVED || (this._status = h.FULFILLED, this._value = e, this._callCallbacks(this._fulfilledCallbacks, e), this._fulfilledCallbacks = this._rejectedCallbacks = this._progressCallbacks = n);
        },
        _reject: function _reject(e) {
          this._status > h.RESOLVED || (this._status = h.REJECTED, this._value = e, this._callCallbacks(this._rejectedCallbacks, e), this._fulfilledCallbacks = this._rejectedCallbacks = this._progressCallbacks = n);
        },
        _notify: function _notify(e) {
          this._callCallbacks(this._progressCallbacks, e);
        },
        _addCallbacks: function _addCallbacks(e, t, r, o, i) {
          r && !s(r) ? (i = r, r = n) : o && !s(o) && (i = o, o = n);
          var a;
          this.isRejected() || (a = {
            defer: e,
            fn: s(t) ? t : n,
            ctx: i
          }, this.isFulfilled() ? this._callCallbacks([a], this._value) : this._fulfilledCallbacks.push(a)), this.isFulfilled() || (a = {
            defer: e,
            fn: r,
            ctx: i
          }, this.isRejected() ? this._callCallbacks([a], this._value) : this._rejectedCallbacks.push(a)), this._status <= h.RESOLVED && this._progressCallbacks.push({
            defer: e,
            fn: o,
            ctx: i
          });
        },
        _callCallbacks: function _callCallbacks(e, n) {
          var t = e.length;
          if (t) {
            var r = this.isResolved(),
              i = this.isFulfilled(),
              s = this.isRejected();
            o(function () {
              for (var o, a, u, c = 0; c < t;) {
                if (o = e[c++], a = o.defer, u = o.fn) {
                  var l,
                    f = o.ctx;
                  try {
                    l = f ? u.call(f, n) : u(n);
                  } catch (d) {
                    a.reject(d);
                    continue;
                  }
                  r ? a.resolve(l) : a.notify(l);
                } else i ? a.resolve(n) : s ? a.reject(n) : a.notify(n);
              }
            });
          }
        }
      };
      var y = {
        cast: function cast(e) {
          return _.cast(e);
        },
        all: function all(e) {
          return _.all(e);
        },
        race: function race(e) {
          return _.anyResolved(e);
        },
        resolve: function resolve(e) {
          return _.resolve(e);
        },
        reject: function reject(e) {
          return _.reject(e);
        }
      };
      for (var g in y) {
        y.hasOwnProperty(g) && (m[g] = y[g]);
      }
      var _ = {
        Deferred: v,
        Promise: m,
        defer: function defer() {
          return new v();
        },
        when: function when(e, n, t, r, o) {
          return _.cast(e).then(n, t, r, o);
        },
        fail: function fail(e, t, r) {
          return _.when(e, n, t, r);
        },
        always: function always(e, n, t) {
          return _.when(e).always(n, t);
        },
        progress: function progress(e, n, t) {
          return _.when(e).progress(n, t);
        },
        spread: function spread(e, n, t, r) {
          return _.when(e).spread(n, t, r);
        },
        done: function done(e, n, t, r, o) {
          _.when(e).done(n, t, r, o);
        },
        isPromise: function isPromise(e) {
          return a(e) && s(e.then);
        },
        cast: function cast(e) {
          return e && e._vow ? e : _.resolve(e);
        },
        valueOf: function valueOf(e) {
          return e && s(e.valueOf) ? e.valueOf() : e;
        },
        isFulfilled: function isFulfilled(e) {
          return !e || !s(e.isFulfilled) || e.isFulfilled();
        },
        isRejected: function isRejected(e) {
          return !(!e || !s(e.isRejected)) && e.isRejected();
        },
        isResolved: function isResolved(e) {
          return !e || !s(e.isResolved) || e.isResolved();
        },
        resolve: function resolve(e) {
          var n = _.defer();
          return n.resolve(e), n.promise();
        },
        fulfill: function fulfill(e) {
          var n = _.defer(),
            t = n.promise();
          return n.resolve(e), t.isFulfilled() ? t : t.then(null, function (e) {
            return e;
          });
        },
        reject: function reject(e) {
          var n = _.defer();
          return n.reject(e), n.promise();
        },
        invoke: function invoke(n, t) {
          var r,
            o = Math.max(arguments.length - 1, 0);
          if (o) {
            r = Array(o);
            for (var i = 0; i < o;) {
              r[i++] = arguments[i];
            }
          }
          try {
            return _.resolve(r ? n.apply(e, r) : n.call(e));
          } catch (s) {
            return _.reject(s);
          }
        },
        all: function all(e) {
          var n = new v(),
            t = c(e),
            r = t ? l(e) : f(e),
            o = r.length,
            i = t ? [] : {};
          if (!o) return n.resolve(i), n.promise();
          var s = o;
          return _._forEach(e, function (e, t) {
            i[r[t]] = e, --s || n.resolve(i);
          }, n.reject, n.notify, n, r), n.promise();
        },
        allResolved: function allResolved(e) {
          var n = new v(),
            t = c(e),
            r = t ? l(e) : f(e),
            o = r.length,
            i = t ? [] : {};
          if (!o) return n.resolve(i), n.promise();
          var s = function s() {
            --o || n.resolve(e);
          };
          return _._forEach(e, s, s, n.notify, n, r), n.promise();
        },
        allPatiently: function allPatiently(e) {
          return _.allResolved(e).then(function () {
            var n,
              t,
              r,
              o,
              i = c(e),
              s = i ? l(e) : f(e),
              a = s.length,
              u = 0;
            if (!a) return i ? [] : {};
            for (; u < a;) {
              r = s[u++], o = e[r], _.isRejected(o) ? (n || (n = i ? [] : {}), i ? n.push(o.valueOf()) : n[r] = o.valueOf()) : n || ((t || (t = i ? [] : {}))[r] = _.valueOf(o));
            }
            if (n) throw n;
            return t;
          });
        },
        any: function any(e) {
          var n = new v(),
            t = e.length;
          if (!t) return n.reject(Error()), n.promise();
          var r,
            o = 0;
          return _._forEach(e, n.resolve, function (e) {
            o || (r = e), ++o === t && n.reject(r);
          }, n.notify, n), n.promise();
        },
        anyResolved: function anyResolved(e) {
          var n = new v(),
            t = e.length;
          return t ? (_._forEach(e, n.resolve, n.reject, n.notify, n), n.promise()) : (n.reject(Error()), n.promise());
        },
        delay: function delay(e, n) {
          return _.resolve(e).delay(n);
        },
        timeout: function timeout(e, n) {
          return _.resolve(e).timeout(n);
        },
        _forEach: function _forEach(e, n, t, r, o, i) {
          for (var s = i ? i.length : e.length, a = 0; a < s;) {
            _.when(e[i ? i[a] : a], p(n, a), t, r, o), ++a;
          }
        },
        TimedOutError: d("TimedOut")
      };
      _.__nextTick__ = o;
      var E = !0;
      "object" == _typeof(r) && "object" == _typeof(r.exports) && (r.exports = _, E = !1), "object" == (typeof modules === "undefined" ? "undefined" : _typeof(modules)) && s(modules.define) && (modules.define("vow", function (e) {
        e(_);
      }), E = !1), "function" == typeof t && (t(function (e, n, t) {
        t.exports = _;
      }), E = !1), E && (e.vow = _);
    }("undefined" != typeof window ? window : n), r.exports;
  }(), t.utils = function (e) {
    function n(n) {
      return e[n];
    }
    var t = {
        exports: {}
      },
      r = t.exports,
      o = n("vow"),
      i = Object.prototype.hasOwnProperty;
    return r.nextTick = o.__nextTick__, o.__nextTick__ = void 0, r.isArray = Array.isArray ? Array.isArray : function (e) {
      return "[object Array]" === Object.prototype.toString.call(e);
    }, r.extend = Object.assign ? Object.assign : function (e) {
      for (var n = 1, t = arguments.length; n < t; n++) {
        var r = arguments[n];
        if (null != r) for (var o in r) {
          i.call(r, o) && (e[o] = r[o]);
        }
      }
      return e;
    }, r.accessDeep = function (e, n) {
      for (var t = n.split("."), r = 0; r < t.length - 1; r++) {
        var o = t[r];
        e[o] = e[o] || {}, e = e[o];
      }
      return {
        parent: e,
        name: t[t.length - 1]
      };
    }, r.createPackage = function (e, n, t) {
      var o = r.registerImports({}, e, n);
      return t && (o.__expand = {
        depends: e,
        imports: n
      }), o;
    }, r.registerImports = function (e, n, t) {
      for (var o = 0; o < n.length; o++) {
        if (t[o].__expand) r.registerImports(e, t[o].__expand.depends, t[o].__expand.imports);else {
          var i = r.accessDeep(e, n[o]);
          i.parent[i.name] = t[o];
        }
      }
      return e;
    }, t.exports;
  }({
    vow: t.vow
  });
  var r = t.env.namespace ? t.utils.accessDeep(n, t.env.namespace) : null;
  r && r.parent && r.parent[r.name] && r.parent[r.name].modules && r.parent[r.name].ready && console.error("(Yandex Maps JS API): api is already enabled on this page with same namespace."), function () {
    function e(e) {
      return "undefined" == typeof f[e] ? f[e] = n(e) : f[e];
    }
    function n(e) {
      return r(e) || r(d + i(e)) || r(t.env.browser.cssPrefix + i(e));
    }
    function r(e) {
      return "undefined" != typeof o().style[e] ? e : null;
    }
    function o() {
      return u || (u = document.createElement("div"));
    }
    function i(e) {
      return e ? e.substr(0, 1).toUpperCase() + e.substr(1) : e;
    }
    function s(n) {
      var t = e(n);
      return t && t != n && (t = "-" + d + "-" + n), t;
    }
    function a(n) {
      return c[n] && e("transitionProperty") ? s(c[n]) : null;
    }
    var u,
      c = {
        transform: "transform",
        opacity: "opacity",
        transitionTimingFunction: "transition-timing-function",
        userSelect: "user-select",
        height: "height"
      },
      l = {},
      f = {},
      d = t.env.browser.cssPrefix.toLowerCase();
    t.supports.css = {
      checkProperty: e,
      checkTransitionProperty: function checkTransitionProperty(e) {
        return "undefined" == typeof l[e] ? l[e] = a(e) : l[e];
      },
      checkTransitionAvailability: a
    };
  }(), t.supports.csp = {
    isSupported: "undefined" != typeof Blob && "undefined" != typeof URL,
    isNonceSupported: t.env.browser.name && t.env.browser.version ? !(t.env.browser.name.search("Safari") != -1 && parseInt(t.env.browser.version) < 10) : null
  }, function () {
    function e() {
      if (!window.WebGLRenderingContext) return !1;
      var e = {
          "Samsung Internet": !0,
          AndroidBrowser: !0
        },
        n = "Webkit" == t.env.browser.engine && +t.env.browser.engineVersion < 537;
      return !n && !e[t.env.browser.name];
    }
    function n() {
      if (!e()) return null;
      var n, t;
      try {
        var r = document.createElement("canvas");
        t = r.getContext(n = "webgl", o), t || (t = r.getContext(n = "experimental-webgl", o), t || (n = null));
      } catch (i) {
        n = null;
      }
      return n ? {
        contextName: n,
        context: t
      } : null;
    }
    function r(e, n) {
      e.width = 226, e.height = 256, n.fillStyle = "#fff", n.fillRect(0, 0, 150, 150), n.globalCompositeOperation = "xor", n.fillStyle = "#f00", n.fillRect(10, 10, 100, 100), n.fillStyle = "#0f0", n.fillRect(50, 50, 100, 100);
      for (var t = n.getImageData(49, 49, 2, 2), r = [], o = 0; o < 16; o++) {
        r.push(t.data[o]);
      }
      return "0x0x0x0x0x0x0x0x0x0x0x0x0x255x0x255" == r.join("x");
    }
    var o = {
        failIfMajorPerformanceCaveat: !0,
        antialias: !1
      },
      i = {};
    t.supports.graphics = {
      hasSvg: function hasSvg() {
        return "svg" in i || (i.svg = document.implementation && document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1")), i.svg;
      },
      hasCanvas: function hasCanvas() {
        if (!("canvas" in i)) {
          var e = document.createElement("canvas"),
            n = "getContext" in e ? e.getContext("2d") : null;
          i.canvas = !!n && r(e, n);
        }
        return i.canvas;
      },
      hasWebGl: function hasWebGl() {
        return "webgl" in i || (i.webgl = n()), i.webgl;
      },
      redetect: function redetect() {
        i = {};
      },
      getWebGlContextName: function getWebGlContextName() {
        return i.webgl && i.webgl.contextName;
      }
    };
  }(), function () {
    function e() {
      var e = !0;
      "MacOS" == t.env.browser.osFamily && /^10\.[0-8](\.|$)/.test(t.env.browser.osVersion) && (e = !1, n("OldMac"));
      var i = ["requestAnimationFrame", "Worker", "URL", "Blob", "XMLHttpRequest", "Set", "Map", "WebAssembly"];
      i.forEach(function (t) {
        window[t] || (e = !1, n(t));
      }), "function" != typeof Math.trunc && (e = !1, n("MathTrunc"));
      var s = t.supports.graphics.hasWebGl();
      if (!s || "webgl" !== s.contextName) return n("hasWebGl"), !1;
      var a = s.context;
      0 == a.getParameter(a.MAX_VERTEX_TEXTURE_IMAGE_UNITS) && (e = !1, n("MAX_VERTEX_TEXTURE_IMAGE_UNITS")), a.getExtension("OES_vertex_array_object") || (e = !1, n("OES_vertex_array_object")), a.getExtension("OES_standard_derivatives") || (e = !1, n("OES_standard_derivatives"));
      var u = a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.HIGH_FLOAT);
      if (u && 0 != u.precision || (e = !1, n("highp")), !r()) {
        var c = o();
        e = !1, t.count("error", {
          path: ["vectorEngine.drawPointsError", t.env.browser.platform, t.env.browser.name, c.vendor, c.renderer].join("."),
          share: 1
        });
      }
      return e;
    }
    function n(e) {
      var n = o();
      t.count("error", {
        path: ["vectorEngine.reasonsVectorNotSupported", e, t.env.browser.platform, t.env.browser.name, n.vendor, n.renderer].join("."),
        share: .1
      });
    }
    function r() {
      var e = document.createElement("canvas");
      e.width = 1, e.height = 1;
      var n = e.getContext("webgl", {
          alpha: !1,
          depth: !1,
          antialias: !1
        }),
        t = n.createShader(n.VERTEX_SHADER);
      n.shaderSource(t, "#version 100\nattribute vec2 p;\nvoid main() {\n    gl_Position = vec4(p,0,1);\n    gl_PointSize = 1.0;\n}"), n.compileShader(t);
      var r = n.createShader(n.FRAGMENT_SHADER);
      n.shaderSource(r, "#version 100\nvoid main() {\n    gl_FragColor = vec4(1, 0, 0, 1);\n}"), n.compileShader(r);
      var o = n.createProgram();
      n.attachShader(o, t), n.attachShader(o, r), n.bindAttribLocation(o, 0, "p"), n.linkProgram(o);
      var i = n.createBuffer();
      n.bindBuffer(n.ARRAY_BUFFER, i), n.bufferData(n.ARRAY_BUFFER, new Float32Array([0, 0]), n.STATIC_DRAW), n.enableVertexAttribArray(0), n.vertexAttribPointer(0, 2, n.FLOAT, !1, 0, 0), n.clearColor(0, 1, 0, 1), n.clear(n.COLOR_BUFFER_BIT), n.useProgram(o), n.drawArrays(n.POINTS, 0, 1);
      var s = new Uint8Array(4);
      return n.readPixels(0, 0, 1, 1, n.RGBA, n.UNSIGNED_BYTE, s), 255 === s[0];
    }
    function o() {
      var e = {},
        n = t.supports.graphics.hasWebGl();
      if (!n) return e;
      var r = n.context,
        o = r.getExtension("WEBGL_debug_renderer_info");
      return o && (e.vendor = r.getParameter(o.UNMASKED_VENDOR_WEBGL).replace(/\W/g, "_"), e.renderer = r.getParameter(o.UNMASKED_RENDERER_WEBGL).replace(/\W/g, "_")), e;
    }
    var i;
    t.supports.vector = {
      isSupported: function isSupported() {
        return void 0 === i && (i = e()), i;
      }
    };
  }(), t.supports.printPatchNeeded = !t.supports.css.checkProperty("printColorAdjust"), t.logger = function (e) {
    function n(e, n) {
      var r = "";
      return t.env.debug && (r += "(" + e + "): "), r += n;
    }
    var r = {
        exports: {}
      },
      o = (r.exports, "Yandex Maps JS API");
    return r.exports = {
      assert: function assert(e, r) {
        e || t.env.debug && console.log(n(o, r));
      },
      log: function log(e) {
        t.env.debug && console.log(n(o, e));
      },
      notice: function notice(e) {
        t.env.debug && console.info(n(o, e));
      },
      warning: function warning(e) {
        t.env.debug && console.warn(n(o, e));
      },
      error: function error(e) {
        console.error(n(o, e));
      },
      exception: function exception(e, t) {
        throw new Error(n(e, t));
      }
    }, r.exports;
  }(), function () {
    var e = t.env.browser;
    e.documentMode = document.documentMode, e.isIE = "MSIE" == e.name || "IEMobile" == e.name, e.isEdge = "Edge" == e.engine, e.isChromium = e.base && "chromium" == e.base.toLocaleLowerCase(), e.isSafari = "Safari" == e.name;
    var n = "Edge" == e.engine || "MSIE" == e.name && e.osVersion > 6.1 || "IEMobile" == e.name && e.engineVersion >= 6;
    n ? e.eventMapper = "pointer" : e.eventMapper = "touchMouse", e.androidBrokenBuild = "AndroidBrowser" == e.name && "534.30" == e.engineVersion;
    var r = window.devicePixelRatio || screen.deviceXDPI && screen.deviceXDPI / 96 || 1,
      o = "iOS" === e.osFamily || "Safari" === e.name || "WebKit" === e.engine && "Safari" === e.base;
    "MSIE" == e.name || "IEMobile" == e.name || "Android" == e.osFamily && "Gecko" == e.engine || o || r > 1 && r < 2 ? e.graphicsRenderEngine = "svg" : e.graphicsRenderEngine = "canvas", e.transformTransition = "Android" == e.osFamily || "iOS" == e.osFamily || "MSIE" == e.name || e.isChromium, e.css3DTransform = "WebKit" == e.engine && !("Android" == e.osFamily && parseFloat(e.osVersion) < 3) || "Gecko" == e.engine && parseInt(e.engineVersion.split(".")[0]) >= 10, e.unsupported = "OperaMini" == e.name;
  }();
  var o = function (e) {
      function n(n) {
        return e[n];
      }
      function t(e) {
        this._config = e, this._sandbox = this._config.createSandbox(this), this._definitionsByName = Object.create(null), this._definitionsByStorage = Object.create(null), this._remoteLoadingAllowed = f.defer(), this._initialized = this._remoteLoadingAllowed.promise().then(function () {
          return this._loadBundle(this._config.initialBudleName);
        }, this);
      }
      function r(e, n, t, r, o, i, s, a, u) {
        this.state = e, this.alias = null, this.name = n, this.storage = t, this.key = r, this.depends = o, this.dynamicDepends = a, this.declaration = i, this.context = s, this.exports = e === m.DEFINED ? u : void 0, this.resolvingPromise = void 0, this.fetchingDeferred = void 0;
      }
      function o(e, n) {
        if (!e.dynamicDepends) return h;
        var t = [];
        for (var r in e.dynamicDepends) {
          if (p.call(e.dynamicDepends, r)) for (var o = 0, i = n.length; o < i; o++) {
            var a = n[o];
            if (void 0 !== a) {
              var u = e.dynamicDepends[r](a);
              s(u) && t.push(u);
            }
          }
        }
        return t;
      }
      function i(e, n, t) {
        return p.call(e.dynamicDepends, n) ? e.dynamicDepends[n].call(null, t) : v;
      }
      function s(e) {
        return "string" == typeof e || u(e);
      }
      function a(e) {
        return e && "object" == _typeof(e) ? e.key + "@" + e.storage : String(e);
      }
      function u(e) {
        return null != e && "object" == _typeof(e) && "string" == typeof e.key && "string" == typeof e.storage;
      }
      function c(e) {
        var n = d.isArray(e);
        return "object" == _typeof(e) && !n && p.call(e, "modules") ? {
          modules: d.isArray(e.modules) ? e.modules : [e.modules],
          data: e.data
        } : n ? {
          modules: e
        } : {
          modules: [e]
        };
      }
      var l = {
          exports: {}
        },
        f = (l.exports, n("vow")),
        d = n("./ym.utils"),
        p = Object.prototype.hasOwnProperty,
        v = {},
        h = Object.freeze([]),
        m = {
          MENTIONED: 1,
          QUEUED: 2,
          FETCHING: 3,
          DECLARED: 4,
          RESOLVING: 5,
          ERROR: 6,
          DEFINED: 7
        };
      return l.exports = t, t.prototype.allowRemoteLoading = function () {
        this._remoteLoadingAllowed.resolve();
      }, t.prototype.isDefined = function (e) {
        return Boolean(this._findDefinition(e));
      }, t.prototype.preload = function (e) {
        return e;
      }, t.prototype.define = function (e, n, t, o) {
        var i, s, a, u;
        if ("object" == _typeof(e)) {
          var c = e;
          e = c.name, s = c.storage, i = c.key, n = c.depends, t = c.declaration, o = c.context, a = c.dynamicDepends, u = c.exports;
        } else 2 === arguments.length && (t = n, n = null);
        var l = new r(m.DECLARED, e, s, i, n, t, o, a, u);
        this._define(l);
      }, t.prototype.defineSync = function (e) {
        var n = new r(m.DEFINED, e.name, e.storage, e.key, null, null, null, null, e.module);
        this._define(n);
      }, t.prototype._define = function (e) {
        function n() {
          var n = new Error("ymaps.modules: redefinition of " + e.name);
          throw console.error(n), n;
        }
        var t = this._definitionsByName[e.name];
        if (t) {
          if (t.state >= m.DECLARED) return;
          return t.state !== m.FETCHING && n(), t.state = m.DECLARED, t.declaration = e.declaration, t.context = e.context, t.storage = e.storage, t.key = e.key, e.depends && ("function" == typeof e.depends && (e.depends = e.depends.call({
            name: e.name
          }, this._config.dependenciesContext)), t.depends = e.depends), t.dynamicDepends = e.dynamicDepends, void (t.exports = e.exports);
        }
        "function" == typeof e.depends && (e.depends = e.depends.call({
          name: e.name
        }, this._config.dependenciesContext)), e.depends = e.depends || h, this._definitionsByName[e.name] = e, this._saveDefinitionToStorage(e);
      }, t.prototype._resolve = function (e, n) {
        if (!e.dynamicDepends) {
          if (e.state === m.DEFINED) return f.resolve(e.exports);
          if (e.state === m.ERROR) return f.reject(e.exports);
        }
        e.state < m.RESOLVING && !e.resolvingPromise && (e.resolvingPromise = this._resolveCore(e, n).always(function (n) {
          return e.resolvingPromise = void 0, n;
        }));
        var t = o(e, [n]);
        return f.all([e.resolvingPromise, this._require(t, n)]).then(function () {
          return e.state === m.DEFINED ? f.resolve(e.exports) : f.reject(e.exports);
        });
      }, t.prototype._resolveCore = function (e, n) {
        return this._fetchModule(e, n).then(function () {
          return e.state = m.RESOLVING, this._require(e.depends, n);
        }, this).then(function (n) {
          function t(n, t) {
            e.state === m.RESOLVING && (e.state = t ? m.ERROR : m.DEFINED, e.exports = t || n), o && o.resolve(), t && console.warn("ymaps.modules: provide(undefined, error) is deprecated and will be removed, throw instead. Module `" + e.name + "`.");
          }
          var r, o;
          t.async = function (n) {
            e.state === m.RESOLVING && (r = n.then(function (e) {
              t(e);
            }, function (e) {
              t(void 0, e);
            }));
          }, t.provide = t, t.provideAsync = t.async, t.dynamicDepends = e.dynamicDepends ? {
            getValue: function (n, t) {
              var r = i(e, n, t);
              return r === v ? f.reject(new Error("ymaps.modules: dynamic dependency `" + n + "` is not declared.")) : s(r) ? this._require([r], t) : f.resolve([r]);
            }.bind(this),
            getValueSync: function (n, t) {
              var r = i(e, n, t);
              if (!s(r)) return r;
              var o = this._findDefinition(r);
              return o ? this._requireSingleSync(o, t) : void 0;
            }.bind(this)
          } : null;
          var a = e.context || {
            name: e.name,
            depends: e.depends
          };
          try {
            e.declaration.apply(a, [t].concat(n));
          } catch (u) {
            return e.state = m.ERROR, void (e.exports = u);
          }
          return r ? r : e.state !== m.DEFINED && e.state !== m.ERROR ? (console.warn("ymaps.modules: asynchronous provide is deprecated and will be removed. Module `" + e.name + "`."), o = f.defer(), o.promise()) : void 0;
        }, this);
      }, t.prototype.require = function (e, n, t, r) {
        var o = "object" == _typeof(e) && !d.isArray(e),
          i = 1 === arguments.length;
        o && (n = e.successCallback, t = e.errorCallback, r = e.context, i = !n && !t), e = c(e);
        var s = this._require(e.modules, e.data);
        return i ? s : void s.spread(n, t, r);
      }, t.prototype.requireSync = function (e) {
        if (e = c(e), 1 !== e.modules.length) throw new Error("ymaps.modules: only one module can be required synchronously.");
        var n = this._findDefinition(e.modules[0]);
        return n && this._requireSingleSync(n, e.data);
      }, t.prototype._requireSingleSync = function (e, n) {
        for (var t = o(e, [n]), r = 0, i = t.length; r < i; r++) {
          var s = this._findDefinition(t[r]);
          if (!s || !this._requireSingleSync(s, n)) return;
        }
        return e.state === m.DEFINED ? e.exports : void 0;
      }, t.prototype._require = function (e, n) {
        var t = e.map(function (e) {
          return this._requireSingle(e, n);
        }, this);
        return f.all(t);
      }, t.prototype._requireSingle = function (e, n) {
        var t = this._findDefinition(e);
        return t ? this._resolve(t, n) : this._initialized.then(function () {
          var t = this._findDefinition(e);
          return t ? this._resolve(t, n) : f.reject(new Error("ymaps.modules: module `" + a(e) + "` is not defined."));
        }, this);
      }, t.prototype._findDefinition = function (e) {
        if ("undefined" != typeof e) return "string" == typeof e ? this._definitionsByName[e] : this._definitionsByStorage[e.storage] && this._definitionsByStorage[e.storage][e.key];
      }, t.prototype._saveDefinitionToStorage = function (e, n) {
        if (e.key && e.storage) {
          n = n || {
            key: e.key,
            storage: e.storage
          };
          for (var t = d.isArray(n.key) ? n.key : [n.key], r = 0, o = t.length; r < o; r++) {
            this._definitionsByStorage[n.storage] = this._definitionsByStorage[n.storage] || {}, this._definitionsByStorage[n.storage][t[r]] = e;
          }
        }
      }, t.prototype._fetchModule = function (e) {
        return e.state >= m.DECLARED ? f.resolve() : this._loadFullBundle();
      }, t.prototype._loadFullBundle = function () {
        if (!this._fullBundlePromise) {
          for (var e in this._definitionsByName) {
            this._definitionsByName[e].state === m.MENTIONED && (this._definitionsByName[e].state = m.FETCHING);
          }
          this._fullBundlePromise = this._loadBundle("full");
        }
        return this._fullBundlePromise;
      }, t.prototype._loadBundle = function (e) {
        return this._config.fetchBundle(e).then(function (e) {
          function n() {
            return f.delay().then(function () {
              var e = o.splice(0, i);
              if (e.forEach(function (e) {
                e(t);
              }), o.length > 0) return n();
            });
          }
          e.missingModules.forEach(function (e) {
            var n = new r(m.MENTIONED, e, void 0, void 0, [], null, null, void 0);
            this._definitionsByName[e] = n;
          }, this);
          var t = this._sandbox,
            o = e.modules,
            i = 400;
          return n();
        }, this)["catch"](function (n) {
          throw console.error('ymaps: Failed to bundle "' + e + '".' + (n ? n.stack || n.message || "" : "")), n;
        });
      }, t.prototype._loadModulesMap = function () {
        return this._config.fetchMap().spread(function (e, n) {
          this._processLoadedMap(e), n();
        }, this);
      }, l.exports;
    }({
      vow: t.vow,
      "./ym.utils": t.utils
    }),
    i = t.env.server.url + "/" + t.env.server.path.replace(/\/$/, "") + "/images/";
  t.modules = new o({
    dependenciesContext: t,
    initialBudleName: t.env.preload.bundle,
    fetchBundle: function fetchBundle(e) {
      var r = ("__ymaps_" + t.env.namespace + "_" + Date.now()).replace(/\W/g, "_");
      n[r] = t.ns;
      var o = document.createElement("script");
      o.src = t.env.hosts["static"] + t.env.bundles.PREFIX + t.env.bundles[e], o.setAttribute("data-ymaps-api-ns", r), o.setAttribute("data-ymaps-api-version", "2.1.79"), o.async = !0;
      var i = t.vow.defer();
      return o.onerror = i.reject.bind(i), t.ns.__provideBundle = i.resolve.bind(i), document.head.appendChild(o), i.promise().always(function (e) {
        return delete n[r], e;
      });
    },
    createSandbox: function createSandbox(e) {
      var n = Object.create(e);
      n.importImages = function (e) {
        return {
          get: function get(n) {
            return i + e[n].src;
          }
        };
      };
      var r = t.utils.extend({}, t, {
          modules: n
        }),
        o = {};
      return Object.defineProperty(r, "__mock__", {
        get: function get() {
          return t.ns.__mock__ || o;
        },
        configurable: !1
      }), r;
    }
  }), t.ns.load = function (e, n, r, o) {
    return "function" == typeof e ? n ? t.ns.ready(["package.full"], e, n) : t.ns.ready(["package.full"], e) : ("string" == typeof e && (e = [e]), t.ns.ready.apply(this, arguments));
  }, function () {
    function e(e) {
      return function () {
        console.warn("{NS}.modules.{FN} is not a public API and will be removed from {NS}.modules.".replace(/\{NS\}/g, t.env.namespace).replace(/\{FN\}/g, e));
        var n = t.modules[e].apply(t.modules, arguments);
        return n === t.modules ? t.ns.modules : n;
      };
    }
    t.ns.modules = {
      require: function require() {
        return t.modules.require.apply(t.modules, arguments);
      },
      isDefined: function isDefined() {
        return t.modules.isDefined.apply(t.modules, arguments);
      },
      requireSync: function requireSync() {
        return t.modules.requireSync.apply(t.modules, arguments);
      },
      define: function define(e, n, r, o) {
        return t.modules.define.apply(t.modules, arguments), t.ns.modules;
      },
      defineSync: e("defineSync"),
      getDefinition: e("getDefinition"),
      getState: e("getState"),
      setOptions: e("setOptions"),
      flush: e("flush"),
      nextTick: e("nextTick"),
      watchResolving: e("watchResolving"),
      __modules: t.modules
    };
  }(), function (e) {
    function n() {
      c && (c = !1);
      var e = {};
      arguments.length && (1 != arguments.length || "object" != _typeof(arguments[0]) || arguments[0].length ? "function" != typeof arguments[0] ? (e.require = "string" == typeof arguments[0] ? [arguments[0]] : arguments[0], e.successCallback = arguments[1], e.errorCallback = arguments[2] && "function" == typeof arguments[2] ? arguments[2] : null, e.context = arguments[2] && "object" == _typeof(arguments[2]) ? arguments[2] : arguments[3]) : (e.successCallback = arguments[0], e.errorCallback = arguments[1] && "function" == typeof arguments[1] ? arguments[1] : null, e.context = arguments[1] && "object" == _typeof(arguments[1]) ? arguments[1] : arguments[2]) : e = arguments[0]);
      var n = e.require || [],
        r = i.all([t.modules.require(n), a, u]).spread(function (e) {
          return t.utils.registerImports(t.ns, n, e), t.ns;
        });
      return r.then(e.successCallback && function (n) {
        setTimeout(e.successCallback.bind(e.context), 0, n);
      }, e.errorCallback && function (n) {
        setTimeout(e.errorCallback.bind(e.context), 0, n);
      }), r;
    }
    function r(n, t) {
      if (n) {
        var r = o(e, n);
        r && setTimeout(function () {
          r.method.call(r.context, t);
        });
      }
    }
    function o(e, n) {
      var t = e;
      n = n.split(".");
      for (var r = 0, o = n.length - 1; r < o; r++) {
        if (t = t[n[r]], !t) return;
      }
      return {
        method: t[n[o]],
        context: t
      };
    }
    var i = t.vow,
      s = [].concat(["package.system"], t.env.preload.load.split(",").filter(Boolean)),
      a = t.modules.require(s).then(function (e) {
        t.utils.registerImports(t.ns, s, e), r(t.env.preload.onLoad, t.ns);
      }, function (e) {
        return r(t.env.preload.onError, e), i.reject(e);
      }),
      u = "complete" === document.readyState || "interactive" === document.readyState ? i.resolve() : new i.Promise(function (e) {
        document.addEventListener("DOMContentLoaded", e, !1), document.addEventListener("load", e, !1);
      });
    t.ns.ready = n;
    var c = !0;
  }(this), t.env.server.params.csp && !t.supports.csp.isSupported && t.logger.warning("CSP is not suported in this browser"), t.modules.define("vectorEngine.loadEngine", ["vow", "Hotspot", "Monitor", "collection.Item", "event.Manager", "hotspot.layer.Hint", "hotspot.layer.optionMapper", "interactivityModel.EventController", "interactivityModel.layer", "option.Manager", "poi.BalloonManager", "util.shapeFactory"], function (e, n) {
    function r() {
      var e = n.defer(),
        r = document.createElement("script");
      return r.onload = e.resolve.bind(e), r.onerror = e.reject.bind(e), r.src = t.env.hosts.vectorIndex.replace("{{version}}", t.env.vectorVersion), t.env.vectorEngineFileName && (r.src = r.src.replace("vector.min.js", t.env.vectorEngineFileName)), document.head.insertAdjacentElement("afterbegin", r), e.promise()["catch"](function () {
        return n.reject(new Error("Failed to load vector engine"));
      });
    }
    if ("ymaps" !== t.env.namespace) throw new Error("Vector supports only `ymaps` namespace.");
    if (null == t.env.vectorVersion) throw new Error("No vector version.");
    var o = null;
    e(function () {
      return o = o || r();
    });
  }), t.modules.define("vectorEngine.preload", [], function (e) {
    t.supports.vector.isSupported() && t.modules.require(["vectorEngine.loadEngine"]).spread(function (e) {
      e();
    }), e({});
  }), t.modules.allowRemoteLoading(), r && (r.parent[r.name] = t.ns), t.env.hasValidApiKey || (t.env.apikey = void 0, "undefined" != typeof t.env.hasValidApiKey && console.warn("(Yandex Maps JS API): Invalid API key"));
})({
  "vectorVersion": "5.21.0",
  "vectorVersionTimestamp": 1668615751823,
  "flags": [],
  "server": {
    "url": "https://api-maps.yandex.ru/2.1.79",
    "path": "build/release",
    "params": {
      "mode": "release",
      "ns": "ymaps",
      "csp": null
    },
    "version": "2.1"
  },
  "preload": {
    "load": "package.full",
    "bundle": "full"
  },
  "mode": "release",
  "debug": false,
  "namespace": "ymaps",
  "enterprise": false,
  "hasApiKeyParam": false,
  "browser": {
    "name": "Chrome",
    "version": "107.0.0.0",
    "base": "Chromium",
    "engine": "WebKit",
    "engineVersion": "537.36",
    "osName": "Windows 10",
    "osFamily": "Windows",
    "osVersion": "10.0",
    "isMobile": false,
    "isTablet": false,
    "multiTouch": false,
    "platform": "Desktop",
    "cssPrefix": "Webkit"
  },
  "lang": "ru_RU",
  "languageCode": "ru",
  "countryCode": "RU",
  "yandexMapDisableAdverts": false,
  "theme": null,
  "dataProvider": null,
  "dataPrestable": false,
  "hosts": {
    "api": {
      "main": "https://api-maps.yandex.ru/",
      "ua": "https://yandex.ru/legal/maps_termsofuse/?lang={{lang}}",
      "maps": "https://yandex.ru/maps/",
      "statCounter": "https://yandex.ru/clck/",
      "services": {
        "coverage": "https://api-maps.yandex.ru/services/coverage/",
        "geocode": "https://geocode-maps.yandex.ru/",
        "geoxml": "https://api-maps.yandex.ru/services/geoxml/",
        "inception": "https://api-maps.yandex.ru/services/inception/",
        "panoramaLocate": "https://api-maps.yandex.ru/services/panoramas/",
        "search": "https://api-maps.yandex.ru/services/search/",
        "suggest": "https://suggest-maps.yandex.ru/",
        "regions": "https://api-maps.yandex.ru/services/regions/",
        "route": "https://api-maps.yandex.ru/services/route/",
        "traffic": "https://api-maps.yandex.ru/services/traffic/"
      }
    },
    "layers": {
      "map": "https://core-renderer-tiles.maps.yandex.net/tiles?l=map&%c&%l",
      "mapj": "https://core-renderer-tiles.maps.yandex.net/tiles?l=mapj&%c&%l&experimental_disable_toponym_hotspots=true",
      "sat": "https://core-sat.maps.yandex.net/tiles?l=sat&%c&%l",
      "skl": "https://core-renderer-tiles.maps.yandex.net/tiles?l=skl&%c&%l",
      "sklj": "https://core-renderer-tiles.maps.yandex.net/tiles?l=sklj&%c&%l",
      "stv": "https://0%d.core-stv-renderer.maps.yandex.net/2.x/tiles?l=stv&%c&v=%v&%l&format=png",
      "sta": "https://0%d.core-stv-renderer.maps.yandex.net/2.x/tiles?l=sta&%c&v=%v&%l&format=png",
      "staHotspot": "https://core-stv-renderer.maps.yandex.net/2.x/tiles?l=stj&%c&v=%v&format=js",
      "staHotspotKey": "%c&l=stj&tm=%v",
      "carparks": "https://core-carparks-renderer-lots.maps.yandex.net/"
    },
    "static": "https://yastatic.net/",
    "metro_RU": "https://yandex.ru/metro/",
    "metro_UA": "https://yandex.com/metro/",
    "metro_BY": "https://yandex.by/metro/",
    "metro_US": "https://yandex.com/metro/",
    "traffic": "https://core-jams-rdr-cache.maps.yandex.net/",
    "trafficInfo": "https://core-jams-info.maps.yandex.net/",
    "trafficArchive": "https://core-jams-rdr-hist.maps.yandex.net/",
    "roadEventsRenderer": "https://core-road-events-renderer.maps.yandex.net/",
    "vectorIndex": "https://yastatic.net/s3/mapsapi-v3/vector/{{version}}/out/vector.min.js",
    "vectorTiles": "https://core-renderer-tiles.maps.yandex.net/vmap2/tiles?lang={{lang}}&x={{x}}&y={{y}}&z={{z}}&zmin={{zmin}}&zmax={{zmax}}&v={{version}}",
    "vectorImages": "https://core-renderer-tiles.maps.yandex.net/vmap2/icons?id={{id}}&scale={{scale}}",
    "vectorMeshes": "https://core-renderer-tiles.maps.yandex.net/vmap2/meshes?id={{id}}",
    "vectorGlyphs": "https://core-renderer-tiles.maps.yandex.net/vmap2/glyphs?lang={{lang}}&font_id={{fontId}}&range={{range}}",
    "indoorTiles": "https://core-renderer-tiles.maps.yandex.net/",
    "panoramasTiles": "https://pano.maps.yandex.net/%s/%z.%x.%y",
    "taxiRouteInfo": "https://taxi-routeinfo.taxi.yandex.net/taxi_info?clid=yamaps&apikey=f6d7c076e16e4d53a928961595e76215&rll={rll}"
  },
  "layers": {
    "map": {
      "version": "22.11.15-1-b221115144500",
      "scaled": true,
      "hotspotZoomRange": [1, 23],
      "hotspotExcludeByTags": ["admin"]
    },
    "skl": {
      "version": "22.11.15-1-b221115144500",
      "scaled": true,
      "hotspotZoomRange": [1, 23],
      "hotspotExcludeByTags": ["admin"]
    },
    "sat": {
      "version": "3.1037.0"
    },
    "sta": {
      "version": "2022.11.16.01.19-1_22.11.15-0-12897"
    },
    "stv": {
      "version": "2022.11.16.01.19-1_22.11.15-0-12897"
    },
    "trf": {
      "version": "1668615840",
      "scaled": true
    },
    "trfe": {
      "version": "",
      "scaled": true,
      "hotspotZoomRange": [0, 21]
    },
    "carparks": {
      "version": "",
      "scaled": true
    }
  },
  "geolocation": {
    "longitude": 27.561481,
    "latitude": 53.902496,
    "isHighAccuracy": false,
    "span": {
      "longitude": 0.686357,
      "latitude": 0.177708
    }
  },
  "token": "64e612e2345dc25fd91d943ed1a78043",
  "distribution": {},
  "version": "2.1.79",
  "majorVersion": "2.1",
  "cssPrefix": "ymaps-2-1-79-",
  "tag": "2.1.79-43",
  "coordinatesOrder": "latlong",
  "taxiInceptionBboxes": [[[56.222595495837346, 28.318534432616705], [60.6841007136798, 33.679862557616836]], [[52.491280779553044, 32.998710213867184], [66.22945422739838, 60.178885995117206]], [[43.5135061217809, 38.38201099511703], [47.556747187256654, 40.00798755761699]], [[54.90279398957107, 60.00310474511678], [57.80455013208442, 66.22136646386686]], [[54.482777526319616, 71.53874927636684], [56.974052764326366, 94.96160083886683]], [[50.475003858253864, 36.24501496093741], [52.745370952398034, 48.37941437499998]], [[48.00105582471142, 43.6772659374999], [49.196048317842866, 45.3911331249999]], [[42.99758363858955, 131.81233673828095], [43.42949289893052, 132.39873200195285]], [[48.341853999370194, 134.93863373535092], [48.634885237261244, 135.20436554687436]], [[52.182556294509006, 103.96680145996015], [52.44850855030791, 104.60400849121018]], [[43.384444182677676, 39.825184393367394], [43.53262442321664, 40.00723128362619]], [[43.5979698518094, 39.905264425715906], [43.71163893715756, 40.29253249212216]], [[51.507196330069355, 54.598325886182714], [52.052357122860414, 55.784849323682764]]],
  "bundles": {
    "panoramas": "/release/panoramas-67f02cdbd424948058b32e826ab1c40c341fed38.js",
    "full": "/release/full-12d3b6ea37df4ec19ca51b92a0651e126f59c33e.js",
    "PREFIX": "s3/front-maps-static/maps-front-jsapi-v2-1/2.1.79-43/build"
  }
}, null);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/timers-browserify/main.js */ "../node_modules/timers-browserify/main.js").setImmediate, __webpack_require__(/*! ./../../../node_modules/process/browser.js */ "../node_modules/process/browser.js")))

/***/ })

/******/ });
//# sourceMappingURL=vendor.min.js.map